This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
components/CheckUpdate.jsx
components/LogLine.jsx
components/LogViewer.jsx
components/RunStreamingPython.jsx
globals.css
hooks/usePythonStreaming.js
layout.js
page.js
utils/checkForUpdate.js
utils/invokePython.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="components/CheckUpdate.jsx">
"use client";

import { useState } from "react";
import { checkForUpdate } from "../utils/checkForUpdate";


export default function CheckUpdate() {
  const [updateMessage, setUpdateMessage] = useState("");
  const [loading, setLoading] = useState(false);

  const handleUpdateCheck = async () => {
    setLoading(true);
    const msg = await checkForUpdate();
    setUpdateMessage(msg);
    setLoading(false);
  };

  return (
 
      <div className="p-4 border rounded">
        <h2 className="text-lg font-bold mb-2">ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆç¢ºèª</h2>
        <button
          onClick={handleUpdateCheck}
          disabled={loading}
          className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:bg-gray-400"
        >
          {loading ? "ç¢ºèªä¸­..." : "ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã‚’ç¢ºèªã™ã‚‹"}
        </button>
        {updateMessage && <p className="mt-4">{updateMessage}</p>}
      </div>
  );
}
</file>

<file path="components/LogLine.jsx">
// components/LogLine.jsx
"use client";

const LogLine = ({ log }) => {
  let color = "text-gray-700";
  let icon = "ğŸ“";

  switch (log.level.toUpperCase()) {
    case "INFO":
      color = "text-blue-600";
      icon = "â„¹ï¸";
      break;
    case "ERROR":
      color = "text-red-600 font-bold";
      icon = "âŒ";
      break;
    case "WARN":
    case "WARNING":
      color = "text-yellow-600";
      icon = "âš ï¸";
      break;
    case "DEBUG":
      color = "text-purple-600";
      icon = "ğŸ›";
      break;
    default:
      icon = "ğŸ§¾";
      break;
  }

  return (
    <div className={`mb-1 ${color} font-mono text-sm`}>
      <span className="mr-2">{icon}</span>
      <span className="opacity-70">[{log.source}]</span>{" "}
      <span>{log.message}</span>
    </div>
  );
};

export default LogLine;
</file>

<file path="components/LogViewer.jsx">
// components/LogViewer.jsx
"use client";

import { useLayoutEffect, useEffect, useState, useRef } from "react";

const LogViewer = ({ children }) => {
  const containerRef = useRef(null);
  const [shouldAutoScroll, setShouldAutoScroll] = useState(true);

  const handleScroll = () => {
    if (!containerRef.current) return;
    const { scrollTop, scrollHeight, clientHeight } = containerRef.current;
    setShouldAutoScroll(scrollHeight - scrollTop - clientHeight < 50); // é–¾å€¤ã‚’50pxã«èª¿æ•´
  };

  useEffect(() => {
    const container = containerRef.current;
    if (container) {
      container.addEventListener("scroll", handleScroll);
      return () => container.removeEventListener("scroll", handleScroll);
    }
  }, []);

  useLayoutEffect(() => {
    if (containerRef.current && shouldAutoScroll) {
      setTimeout(() => {
        containerRef.current.scrollTop = containerRef.current.scrollHeight;
      }, 0);
    }
  }, [children, shouldAutoScroll]);

  return (
    <div
      ref={containerRef}
      className="mt-2 p-2 bg-gray-100 border rounded h-80 overflow-auto whitespace-pre-wrap font-mono text-sm"
    >
      {children}
    </div>
  );
};

export default LogViewer;
</file>

<file path="components/RunStreamingPython.jsx">
// components/RunStreamingPython.jsx
"use client";

import React from "react";
import usePythonStreaming from "../hooks/usePythonStreaming";
import LogViewer from "../components/LogViewer";
import LogLine from "../components/LogLine";

const script = "main.py";
const params = {
  mode: "csv",
  folder: "./data",
  plant_name: "å·¥å ´B",
};


export default function RunStreamingPython() {
  const { logLines, completed } = usePythonStreaming(script, params);
  

  return (
    <div>
      <h2 className="text-lg font-bold">å®Ÿè¡Œãƒ­ã‚°</h2>
      <LogViewer>
        {logLines.map((log, idx) => (
          <LogLine key={idx} log={log} />
        ))}
      </LogViewer>
      {completed && (
        <p className="text-green-600 mt-2 font-medium">
          âœ… å‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸï¼
        </p>
      )}
    </div>
  );
}
</file>

<file path="globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}
</file>

<file path="hooks/usePythonStreaming.js">
// hooks/usePythonStreaming.js
"use client";

import { useEffect, useState } from "react";
import { listen } from "@tauri-apps/api/event";
import { invoke } from "@tauri-apps/api/core";




const usePythonStreaming = (script, params) => {
  const [logLines, setLogLines] = useState([]);
  const [completed, setCompleted] = useState(false);

  useEffect(() => {
    let isUnmounted = false;
    let unlistenCallback = null;

    const startPython = async () => {
 
      try {
        unlistenCallback = await listen("python-log", (event) => {
          if (isUnmounted) return;

          const log = event.payload;

          // ãƒ­ã‚°ã®æ§‹é€ ã‚’æ¤œè¨¼
          if (
            typeof log !== "object" ||
            !("message" in log && "level" in log && "source" in log)
          ) {
            console.warn("å—ä¿¡ãƒ­ã‚°ãŒæ§‹é€ åŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“:", log);
            return;
          }

          setLogLines((prev) => {
            // é€£ç¶šã™ã‚‹é‡è¤‡ãƒ­ã‚°ã®æ’é™¤
            if (prev.length > 0 && prev[prev.length - 1].message === log.message) {
              return prev;
            }
            return [...prev, log];
          });

        //   console.log(log);
          // çµ‚äº†æ¡ä»¶ã®åˆ¤å®š
          if (
            log.message.includes("Pythonãƒ—ãƒ­ã‚»ã‚¹çµ‚äº†")
          ) {
            setCompleted(true);
          }
        });

        if (!isUnmounted) {
          await invoke("run_python_script_streaming", {
            script,
            param: JSON.stringify(params),
          });
        }
      } catch (error) {
        console.error("Pythonå®Ÿè¡Œã‚¨ãƒ©ãƒ¼:", error);
      }
    };

    startPython();

    return () => {
      isUnmounted = true;
      if (unlistenCallback) {
        unlistenCallback();
      }
    };
  }, []);

  return { logLines, completed };
};

export default usePythonStreaming;
</file>

<file path="layout.js">
import localFont from "next/font/local";
import "./globals.css";

const geistSans = localFont({
  src: "./fonts/GeistVF.woff",
  variable: "--font-geist-sans",
  weight: "100 900",
});
const geistMono = localFont({
  src: "./fonts/GeistMonoVF.woff",
  variable: "--font-geist-mono",
  weight: "100 900",
});

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
</file>

<file path="page.js">
"use client";


import RunStreamingPython from "./components/RunStreamingPython";
import CheckUpdate from "./components/CheckUpdate";

export default function Page() {


  return (
    <div className="p-4 space-y-6">
 
      <RunStreamingPython />
      <CheckUpdate/>

    </div>
  );
}
</file>

<file path="utils/checkForUpdate.js">
// ğŸ“ frontend/utils/checkForUpdate.js
import { check } from "@tauri-apps/plugin-updater";
import { relaunch } from "@tauri-apps/plugin-process";

/**
 * ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆç¢ºèªï¼†å®Ÿè¡Œé–¢æ•°ï¼ˆTauri Plugin Updater å¯¾å¿œï¼‰
 */
export async function checkForUpdate() {
  try {
    const update = await check();
    if (update) {
      let downloaded = 0;
      let contentLength = 0;

      await update.downloadAndInstall((event) => {
        switch (event.event) {
          case "Started":
            contentLength = event.data.contentLength;
            console.log(`ğŸ”½ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹: ${contentLength} bytes`);
            break;
          case "Progress":
            downloaded += event.data.chunkLength;
            console.log(`ğŸ“¦ ${downloaded} / ${contentLength} bytes`);
            break;
          case "Finished":
            console.log("âœ… ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†");
            break;
        }
      });

      console.log("ğŸš€ ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆå®Œäº†ã€å†èµ·å‹•ã—ã¾ã™");
      await relaunch();
      return `ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã‚’é©ç”¨ã—ã¦å†èµ·å‹•ã—ã¾ã—ãŸï¼ˆv${update.version}ï¼‰`;
    } else {
      return "âœ… æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã™ã€‚";
    }
  } catch (err) {
    return `ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆç¢ºèªã‚¨ãƒ©ãƒ¼: ${String(err)}`;
  }
}
</file>

<file path="utils/invokePython.js">
// ğŸ“ frontend/utils/invokePython.js
import { invoke } from "@tauri-apps/api/core";

/**
 * Pythonã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’TauriçµŒç”±ã§å®Ÿè¡Œã™ã‚‹å…±é€šé–¢æ•°
 * @param {string} script - Pythonãƒ•ã‚¡ã‚¤ãƒ«åï¼ˆä¾‹: "main.py"ï¼‰
 * @param {Object} params - Pythonã«æ¸¡ã™å¼•æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 * @returns {Promise<string>} Pythonã‚¹ã‚¯ãƒªãƒ—ãƒˆã‹ã‚‰ã®æ–‡å­—åˆ—å‡ºåŠ› or ã‚¨ãƒ©ãƒ¼æ–‡å­—åˆ—
 */
export async function runPythonScript(script, param) {
  try {
    const result = await invoke("run_python_script", {
      script,
      param: JSON.stringify(param),
    });
    return String(result);
  } catch (error) {
    return `Pythonå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: ${String(error)}`;
  }
}
</file>

</files>
